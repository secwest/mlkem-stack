<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ML-KEM (FIPS 203) â€” Cryptographic Operation Layer Stack</title>
<meta name="description" content="Interactive 3D visualization of ML-KEM post-quantum key encapsulation mechanism mathematical operations with FIPS 203 pseudocode">
<style>
  :root {
    --bg: #080c14;
    --bg2: #0a0e17;
    --panel: #111827;
    --border: #1e293b;
    --text: #e2e8f0;
    --textdim: #94a3b8;
    --textmuted: #64748b;
    --textdark: #334155;
    --cyan: #22d3ee;
    --cyandim: #0e7490;
    --green: #34d399;
    --orange: #f59e0b;
    --red: #f87171;
    --purple: #a78bfa;
    --pink: #e879f9;
    --blue: #38bdf8;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', 'Helvetica Neue', system-ui, sans-serif; overflow: hidden; height: 100vh; }
  #app { display: flex; flex-direction: column; height: 100vh; }

  /* Header */
  #header { display: flex; align-items: center; justify-content: space-between; padding: 10px 20px; border-bottom: 1px solid var(--border); background: var(--bg2); flex-shrink: 0; z-index: 10; }
  #header .title-area .sup { font-size: 9px; font-family: 'Courier New', monospace; color: var(--cyandim); letter-spacing: 2.5px; text-transform: uppercase; }
  #header .title-area h1 { font-size: 16px; font-weight: 700; margin: 2px 0 0; }
  #header .title-area h1 .idx { font-family: 'Courier New', monospace; }
  #header .title-area h1 .sep { color: var(--textdark); margin: 0 10px; }
  #header .title-area h1 .count { color: var(--textmuted); font-weight: 400; }
  #header .controls { display: flex; align-items: center; gap: 10px; }
  .phase-tabs { display: flex; gap: 2px; background: var(--panel); border-radius: 6px; padding: 3px; }
  .phase-tab { padding: 6px 14px; background: transparent; border: 1px solid transparent; border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 11px; font-weight: 700; color: var(--textmuted); transition: all 0.2s; }
  .phase-tab.active { background: var(--border); }
  .phase-tab .num { opacity: 0.4; margin-right: 4px; }
  .nav-btns { display: flex; gap: 3px; }
  .nav-btn { width: 28px; height: 28px; background: var(--border); border: 1px solid var(--textdark); border-radius: 4px; color: var(--textdim); cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; transition: background 0.15s; }
  .nav-btn:hover { background: var(--textdark); }
  .pc-toggle { padding: 5px 10px; background: var(--border); border: 1px solid var(--textdark); border-radius: 4px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 10px; font-weight: 700; color: var(--textmuted); transition: all 0.2s; }
  .pc-toggle.active { color: var(--cyan); border-color: var(--cyandim); background: #0e749020; }

  /* Main layout */
  #main { display: flex; flex: 1; min-height: 0; }
  #viewport { flex: 1; position: relative; cursor: grab; }
  #viewport:active { cursor: grabbing; }
  #viewport canvas { display: block; }
  #viewport .hint { position: absolute; bottom: 10px; left: 14px; font-size: 9px; color: var(--textdark); font-family: 'Courier New', monospace; pointer-events: none; }

  /* Sidebar */
  #sidebar { width: 380px; border-left: 1px solid var(--border); background: var(--bg2); display: flex; flex-direction: column; flex-shrink: 0; }
  #sidebar .section-label { padding: 8px 14px; border-bottom: 1px solid var(--border); font-size: 10px; font-family: 'Courier New', monospace; color: var(--textmuted); letter-spacing: 1px; display: flex; align-items: center; justify-content: space-between; }
  #sidebar .section-label .sub { font-size: 8px; color: var(--textdark); }

  /* SVG flowchart area */
  #flowchart-wrap { flex: 1; overflow-y: auto; padding: 4px 0; }
  #flowchart-wrap svg text { pointer-events: none; }
  #flowchart-wrap .fc-node { cursor: pointer; }
  #flowchart-wrap .fc-node:hover rect { stroke-opacity: 0.8 !important; }

  /* Detail panel */
  #detail { border-top: 1px solid var(--border); padding: 12px; flex-shrink: 0; max-height: 440px; overflow-y: auto; transition: background 0.3s; }
  #detail .det-header { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
  #detail .det-dot { width: 10px; height: 10px; border-radius: 2px; }
  #detail .det-name { font-size: 12px; font-weight: 700; }
  #detail .det-type { font-size: 9px; font-family: 'Courier New', monospace; color: var(--textmuted); margin-left: auto; background: var(--border); padding: 2px 6px; border-radius: 3px; }
  #detail .det-alg { font-size: 8px; font-family: 'Courier New', monospace; color: var(--cyan); margin-left: 4px; opacity: 0.7; }
  #detail .det-math { font-size: 11px; font-family: 'Courier New', monospace; color: var(--text); padding: 5px 8px; background: #0d1117; border-radius: 4px; margin-bottom: 6px; line-height: 1.7; word-break: break-word; }
  #detail .det-desc { font-size: 10px; color: var(--textdim); line-height: 1.6; }
  #detail .flow-links { margin-top: 8px; padding-top: 6px; }
  #detail .flow-links .fl-label { font-size: 9px; font-family: 'Courier New', monospace; color: var(--textmuted); }
  #detail .flow-links .fl-badge { font-size: 9px; font-family: 'Courier New', monospace; padding: 1px 5px; border-radius: 3px; margin-right: 3px; cursor: pointer; display: inline-block; margin-bottom: 2px; }
  #detail .loop-box { margin-top: 8px; padding: 6px 8px; border-radius: 4px; }
  #detail .loop-box .loop-title { font-size: 9px; font-weight: 700; font-family: 'Courier New', monospace; margin-bottom: 3px; }
  #detail .loop-box .loop-desc { font-size: 9px; color: var(--textdim); line-height: 1.5; }

  /* Pseudocode panel */
  #pseudocode { border-top: 1px solid var(--border); padding: 0; flex-shrink: 0; max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
  #pseudocode.open { max-height: 260px; }
  #pseudocode .pc-inner { padding: 8px 12px; overflow-y: auto; max-height: 250px; }
  #pseudocode .pc-title { font-size: 9px; font-family: 'Courier New', monospace; color: var(--cyan); letter-spacing: 1px; margin-bottom: 6px; display: flex; align-items: center; gap: 8px; }
  #pseudocode .pc-title .pc-ref { color: var(--textmuted); font-weight: 400; }
  #pseudocode .pc-code { font-size: 10px; font-family: 'Courier New', monospace; line-height: 1.75; color: var(--textdim); white-space: pre-wrap; }
  #pseudocode .pc-code .pc-ln { color: var(--textdark); display: inline-block; width: 22px; text-align: right; margin-right: 10px; user-select: none; }
  #pseudocode .pc-code .pc-hl { color: var(--text); background: #ffffff08; display: inline; border-radius: 2px; padding: 0 2px; }
  #pseudocode .pc-code .pc-kw { color: var(--purple); }
  #pseudocode .pc-code .pc-fn { color: var(--cyan); }
  #pseudocode .pc-code .pc-cm { color: var(--textdark); font-style: italic; }
  #pseudocode .pc-code .pc-var { color: var(--green); }
  #pseudocode .pc-code .pc-op { color: var(--orange); }

  /* Responsive */
  @media (max-width: 900px) {
    #sidebar { width: 300px; }
  }
  @media (max-width: 700px) {
    #main { flex-direction: column; }
    #sidebar { width: 100%; height: 40%; border-left: none; border-top: 1px solid var(--border); }
    #viewport { height: 60%; }
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 5px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
</style>
</head>
<body>
<div id="app">
  <div id="header">
    <div class="title-area">
      <div class="sup">FIPS 203 Â· ML-KEM Post-Quantum Key Encapsulation</div>
      <h1>
        Layer <span class="idx" id="hdr-idx">01</span><span class="count" id="hdr-count"> / 8</span>
        <span class="sep">Â·</span>
        <span id="hdr-name" style="color:var(--cyan)">Seed Generation</span>
      </h1>
    </div>
    <div class="controls">
      <button class="pc-toggle" id="pc-toggle" title="Toggle pseudocode panel (p)">{ } PSEUDOCODE</button>
      <div class="phase-tabs" id="phase-tabs"></div>
      <div class="nav-btns">
        <button class="nav-btn" id="btn-up" title="Previous layer (â†‘ or k)">â†‘</button>
        <button class="nav-btn" id="btn-down" title="Next layer (â†“ or j)">â†“</button>
      </div>
    </div>
  </div>
  <div id="main">
    <div id="viewport">
      <div class="hint">â†‘â†“ j/k navigate Â· drag orbit Â· scroll zoom Â· 1/2/3 switch phase Â· p toggle pseudocode</div>
    </div>
    <div id="sidebar">
      <div class="section-label">
        <span>FLOWCHART Â· <span id="fc-count">8</span> OPS</span>
        <span class="sub">click node to navigate</span>
      </div>
      <div id="flowchart-wrap"></div>
      <div id="pseudocode"><div class="pc-inner" id="pc-inner"></div></div>
      <div id="detail"></div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ML-KEM DATA â€” verified against FIPS 203 Algorithms 13-21
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PHASES = [
  {
    id:"keygen", label:"KEYGEN", color:"#22d3ee",
    alg:"Alg 13: K-PKE.KeyGen(d) + Alg 16: ML-KEM.KeyGen_internal(d,z)",
    flows:[
      {from:0,to:1,label:"Ï seed",type:"data"},
      {from:0,to:2,label:"Ïƒ seed",type:"data"},
      {from:0,to:3,label:"Ïƒ seed",type:"data"},
      {from:2,to:4,label:"s coeffs",type:"data"},
      {from:3,to:4,label:"e coeffs",type:"data"},
      {from:1,to:5,label:"Ã‚ matrix",type:"data"},
      {from:4,to:5,label:"Å (NTT)",type:"seq"},
      {from:4,to:6,label:"Ãª (NTT)",type:"seq"},
      {from:5,to:6,label:"Ã‚âˆ˜Å product",type:"seq"},
      {from:6,to:7,label:"tÌ‚ = Ã‚âˆ˜Å+Ãª",type:"seq"},
    ],
    loops:[],
    layers:[
      {name:"Seed Expansion",
       math:"(Ï, Ïƒ) â† G(d â€– k)",
       desc:"Implementation: call SHA3-512 on (d[0..31] â€– k) where k âˆˆ {2,3,4} is the ML-KEM security level. Output 64 bytes: Ï = first 32 (public, transmitted in ek), Ïƒ = last 32 (secret, used for PRF calls then discarded). Initialize counter N=0 for subsequent PRF invocations. Security: including k in the hash input provides domain separation between parameter sets â€” prevents cross-parameter oracle attacks where an adversary reuses a seed across ML-KEM-512/768/1024. SHA3-512 as G ensures 256-bit preimage resistance for both sub-seeds. Alg 13 line 1.",
       color:"#94a3b8",type:"input",
       algRef:"Alg 13 line 1",
       pseudo:[
         {ln:1, code:'Input: d âˆˆ ğ”¹Â³Â² (seed)', hl:false},
         {ln:2, code:'(Ï, Ïƒ) â† G(d â€– k)', hl:true, cm:'// SHA3-512, k = security param byte'},
         {ln:3, code:'N â† 0', hl:false, cm:'// counter for PRF calls'},
       ]},
      {name:"Matrix Expansion",
       math:"Ã‚[i][j] â† SampleNTT(XOF(Ï â€– j â€– i))",
       desc:"Implementation: for each (i,j) pair, initialize SHAKE-128 with (Ï â€– j â€– i) â€” note column-first index order per FIPS 203. Stream 3-byte chunks, parse as 12-bit pairs dâ‚,dâ‚‚, reject values â‰¥ 3329, accept until 256 coefficients collected. Each accepted value is already in NTT domain. Total: kÂ² SHAKE-128 instances, ~585 bytes consumed each on average. Matrix is deterministic from Ï â€” both parties regenerate identically. Security: rejection sampling ensures Ã‚ is statistically uniform over â„¤_q^(256) â€” any bias would weaken the M-LWE assumption by enabling algebraic distinguishers. Using XOF (SHAKE-128) rather than a block cipher PRF avoids output-length limitations and provides collision resistance against adversaries who try to find Ï values producing structured matrices.",
       color:"#22d3ee",type:"expand",
       algRef:"Alg 13 lines 4-6",
       pseudo:[
         {ln:4, code:'for (i â† 0; i < k; i++)', hl:false},
         {ln:5, code:'  for (j â† 0; j < k; j++)', hl:false},
         {ln:6, code:'    Ã‚[i][j] â† SampleNTT(XOF(Ï, j, i))', hl:true, cm:'// SHAKE-128 â†’ rejection sample'},
       ]},
      {name:"Secret Sampling",
       math:"s[i] â† SamplePolyCBD_Î·â‚(PRF(Ïƒ, N++))  for i in [0,k)",
       desc:"Implementation: PRF = SHAKE-256(Ïƒ â€– N) produces 64Â·Î·â‚ bytes per polynomial. CBD_Î·â‚ splits each 2Î·â‚-byte block into two Î·â‚-bit halves, sums the bits in each half, subtracts â†’ coefficient in [âˆ’Î·â‚, Î·â‚]. Parameters: Î·â‚=2 (ML-KEM-768/1024, 128 bytes/poly) or Î·â‚=3 (ML-KEM-512, 192 bytes/poly). PRF counter N increments k times: N=0..kâˆ’1. Security: CBD is preferred over discrete Gaussian because it is trivially constant-time (no rejection, no floating-point) â€” Gaussian samplers are notoriously vulnerable to timing side-channels that leak secret key bits. The small Î·â‚ values ensure sufficient entropy in s while keeping the M-LWE noise small enough for correct decryption. The PRF-based derivation from Ïƒ means s is pseudorandom under SHAKE-256 security even if the RBG seed d has limited min-entropy.",
       color:"#34d399",type:"sample",
       algRef:"Alg 13 lines 7-8",
       pseudo:[
         {ln:7, code:'for (i â† 0; i < k; i++)', hl:false},
         {ln:8, code:'  s[i] â† SamplePolyCBD_Î·â‚(PRF(Ïƒ, N)); N++', hl:true, cm:'// PRF = SHAKE-256'},
       ]},
      {name:"Error Sampling",
       math:"e[i] â† SamplePolyCBD_Î·â‚(PRF(Ïƒ, N++))  for i in [0,k)",
       desc:"Implementation: identical CBD_Î·â‚ process using counter N=k..2kâˆ’1 (continuing from secret sampling). Same Ïƒ seed, same byte-count per polynomial. The error vector e must be statistically independent of s â€” the incrementing counter N ensures distinct PRF outputs. After this step, Ïƒ and N are no longer needed and should be zeroized. Security: the error vector prevents the public key from being an exact linear function of s. Without e, an adversary could solve t = AÂ·s directly via Gaussian elimination in â„¤_q. The M-LWE hardness assumption requires that (A, AÂ·s+e) is computationally indistinguishable from (A, uniform) â€” the error magnitude Î·â‚ is carefully chosen to balance security (larger e â†’ harder problem) against correctness (smaller e â†’ less decryption noise).",
       color:"#f59e0b",type:"sample",
       algRef:"Alg 13 lines 9-10",
       pseudo:[
         {ln:9, code:'for (i â† 0; i < k; i++)', hl:false},
         {ln:10, code:'  e[i] â† SamplePolyCBD_Î·â‚(PRF(Ïƒ, N)); N++', hl:true},
       ]},
      {name:"NTT (Number Theoretic Transform) Forward",
       math:"Å[i] = NTT(s[i]),  Ãª[i] = NTT(e[i])  âˆ€i",
       desc:"Implementation: 7-layer butterfly network (logâ‚‚256 = 8, but FIPS 203 uses 7 layers operating on pairs). Root of unity Î¶=17 mod q=3329; precompute Î¶^BitRev7(i) for i=0..127 as twiddle factors. In-place: each layer halves the stride, multiplies by twiddle, adds/subtracts. 7Ã—128 = 896 multiply-reduce operations per polynomial, 2k polynomials total. All subsequent arithmetic stays in NTT domain until INTT is needed. Security: the NTT itself is not a security-relevant transform â€” it is purely a performance optimization. However, constant-time NTT implementations must avoid data-dependent branches or memory access patterns in the butterfly operations, as cache-timing attacks (Brumley-Tuveri style) on the twiddle factor lookups could leak information about the secret polynomial s. q = 3329 was specifically chosen so that 256 | (qâˆ’1) and q is prime, enabling both NTT-friendly structure and simple modular arithmetic.",
       color:"#a78bfa",type:"transform",
       algRef:"Alg 13 lines 11-12",
       pseudo:[
         {ln:11, code:'for (i â† 0; i < k; i++)', hl:false},
         {ln:12, code:'  Å[i] â† NTT(s[i])', hl:true},
         {ln:13, code:'for (i â† 0; i < k; i++)', hl:false},
         {ln:14, code:'  Ãª[i] â† NTT(e[i])', hl:true},
       ]},
      {name:"Matrixâ€“Vector Multiply",
       math:"tÌ‚[i] = Î£â±¼ (Ã‚[i][j] âˆ˜ Å[j])   (pointwise in NTT domain)",
       desc:"Implementation: MultiplyNTTs (Alg 11) operates on pairs of coefficients at indices (2i, 2i+1) as degree-1 polynomials mod (XÂ²âˆ’Î³) where Î³=Î¶^(2Â·BitRev7(i)+1). Each base-case: 2 multiplies, 1 add, 1 subtract, 2 reductions mod q. Total per âˆ˜: 128 base-cases = 256 multiplies. Accumulate via coefficient-wise addition mod q. Grand total: kÂ² Ã— 256 multiplications + kÂ² Ã— 256 additions. Security: this is where the Module-LWE structure provides its security advantage â€” the module structure (kÃ—k matrix of ring elements) allows ML-KEM to interpolate between pure Ring-LWE (k=1, efficient but relies on ring structure) and plain LWE (k=n, secure but large keys). The module approach hedges against potential algebraic attacks on ring structure while maintaining compact key sizes.",
       color:"#f87171",type:"compute",
       algRef:"Alg 13 line 15 (partial)",
       pseudo:[
         {ln:15, code:'for (i â† 0; i < k; i++)', hl:false},
         {ln:'', code:'  tÌ‚[i] â† 0', hl:false},
         {ln:'', code:'  for (j â† 0; j < k; j++)', hl:false},
         {ln:'', code:'    tÌ‚[i] â† tÌ‚[i] + Ã‚[i][j] âˆ˜ Å[j]', hl:true, cm:'// âˆ˜ = MultiplyNTTs (Alg 11)'},
       ]},
      {name:"Error Addition",
       math:"tÌ‚ = tÌ‚ + Ãª",
       desc:"Implementation: coefficient-wise addition mod 3329 of Ãª into the accumulated product. 256Ã—k additions. Completes tÌ‚ = Ã‚âˆ˜Å + Ãª in NTT domain, equivalent to t = AÂ·s + e in coefficient domain. This is the M-LWE instance â€” the security assumption is that (Ã‚, tÌ‚) is computationally indistinguishable from (Ã‚, uniform) given small s,e. Security: the best known classical attack is primal lattice sieving with cost ~2^Â¹â´Â³ (ML-KEM-768); the best known quantum attack (Grover-accelerated sieving) costs ~2^Â¹Â²â·. The error addition is what makes this a 'learning with errors' instance rather than a plain linear system â€” without e, an adversary could extract s in O(nÂ³) via linear algebra.",
       color:"#fb923c",type:"compute",
       algRef:"Alg 13 line 15",
       pseudo:[
         {ln:15, code:'tÌ‚ â† Ã‚ âˆ˜ Å + Ãª', hl:true, cm:'// complete M-LWE instance'},
       ]},
      {name:"Key Encoding & Output",
       math:"ek = ByteEncodeâ‚â‚‚(tÌ‚) â€– Ï    dk = ByteEncodeâ‚â‚‚(Å) â€– ek â€– H(ek) â€– z",
       desc:"Implementation: ByteEncodeâ‚â‚‚ packs 256 12-bit coefficients into 384 bytes per polynomial (Alg 5). ek = 384k + 32 bytes. dk layout: dkPKE (384k bytes) â€– ek (384k+32 bytes) â€– H(ek) (32 bytes, SHA3-256) â€– z (32 bytes from RBG). dk total = 768k + 96 bytes. Sizes: ML-KEM-512: ek=800, dk=1632. ML-KEM-768: ek=1184, dk=2400. ML-KEM-1024: ek=1568, dk=3168. Security: H(ek) is precomputed and stored in dk to bind the encapsulation key into the FO hash during decapsulation â€” this prevents an attacker from substituting a different ek during key transport (key-substitution attacks / Chosen-Ciphertext Key Mismatch). The rejection seed z is generated independently from the key material and kept secret â€” it enables implicit rejection without leaking whether decapsulation succeeded or failed, which is essential for IND-CCA2 security.",
       color:"#22d3ee",type:"output",
       algRef:"Alg 13 lines 16-20, Alg 16 lines 1-7",
       pseudo:[
         {ln:16, code:'ekPKE â† ByteEncodeâ‚â‚‚(tÌ‚) â€– Ï', hl:true, cm:'// Alg 13'},
         {ln:17, code:'dkPKE â† ByteEncodeâ‚â‚‚(Å)', hl:false},
         {ln:'', code:'â€” ML-KEM wrapper (Alg 16) â€”', hl:false},
         {ln:4, code:'ek â† ekPKE', hl:false},
         {ln:5, code:'dk â† dkPKE â€– ek â€– H(ek) â€– z', hl:true, cm:'// H = SHA3-256'},
         {ln:6, code:'return (ek, dk)', hl:false},
       ]},
    ],
  },
  {
    id:"encaps", label:"ENCAPSULATE", color:"#f59e0b",
    alg:"Alg 14: K-PKE.Encrypt(ek,m,r) + Alg 17: ML-KEM.Encaps_internal(ek,m)",
    flows:[
      {from:0,to:1,label:"m + H(ek)",type:"data"},
      {from:1,to:2,label:"r coin",type:"data"},
      {from:1,to:3,label:"rÌ‚ via PRF",type:"data"},
      {from:1,to:5,label:"eâ‚‚ via PRF",type:"data"},
      {from:2,to:3,label:"Å· (NTT)",type:"seq"},
      {from:2,to:5,label:"Å· (NTT)",type:"seq"},
      {from:3,to:4,label:"Aáµ€Å· + eâ‚",type:"seq"},
      {from:0,to:5,label:"m bits",type:"data"},
      {from:5,to:6,label:"v raw",type:"seq"},
      {from:4,to:7,label:"Å« compressed",type:"seq"},
      {from:6,to:7,label:"vÌ„ compressed",type:"seq"},
    ],
    loops:[],
    layers:[
      {name:"Message Generation",
       math:"m â†$ ğ”¹Â³Â²",
       desc:"Implementation: draw 32 bytes from an approved DRBG (NIST SP 800-90A). This is NOT a user message â€” it is an internal random seed from which the FO transform deterministically derives all encryption noise and the shared secret. Must never be reused. Alg 20 calls RBG then passes m into Alg 17. Security: m must have full 256-bit entropy â€” if the RBG is weak or predictable, an attacker can enumerate candidate m values, re-derive (KÌ„, r), re-encrypt, and check against the ciphertext. This is a total break. FIPS 203 requires an SP 800-90A approved DRBG (CTR_DRBG or Hash_DRBG) seeded with sufficient entropy. The deterministic derivation of all randomness from m is intentional â€” it enables the FO re-encryption check in decapsulation.",
       color:"#94a3b8",type:"input",
       algRef:"Alg 20 line 1, Alg 17 input",
       pseudo:[
         {ln:1, code:'Input: ek (encapsulation key), m âˆˆ ğ”¹Â³Â²', hl:false},
         {ln:2, code:'(KÌ„, r) â† G(m â€– H(ek))', hl:true, cm:'// G = SHA3-512, H = SHA3-256'},
       ]},
      {name:"Noise Derivation",
       math:"(KÌ„, r) â† G(m â€– H(ek))  then  y,eâ‚,eâ‚‚ â† PRF(r, N++)",
       desc:"Implementation: G = SHA3-512 on (m[0..31] â€– H(ek)[0..31]) yields 64 bytes. KÌ„ = bytes[0..31] (raw shared secret). r = bytes[32..63] (noise derivation coin). Then PRF = SHAKE-256(r â€– N) generates: y[0..k-1] via CBD_Î·â‚ (N=0..k-1), eâ‚[0..k-1] via CBD_Î·â‚‚ (N=k..2k-1), eâ‚‚ via CBD_Î·â‚‚ (N=2k). Î·â‚‚=2 for all parameter sets. Security: hashing m with H(ek) binds the shared secret to this specific public key â€” prevents multi-key attacks where an adversary intercepts ciphertexts and tries them against multiple public keys. The deterministic derivation of all noise from r is the core of the Fujisaki-Okamoto transform: it converts the IND-CPA secure K-PKE into an IND-CCA2 secure KEM by making encryption a deterministic function of m, allowing the decapsulator to verify ciphertext integrity by re-encryption.",
       color:"#f59e0b",type:"expand",
       algRef:"Alg 17 line 1 â†’ Alg 14 lines 9-19",
       pseudo:[
         {ln:1, code:'(KÌ„, r) â† G(m â€– H(ek))', hl:true, cm:'// Alg 17: KÌ„ = future shared secret'},
         {ln:'', code:'â€” inside K-PKE.Encrypt(ek, m, r): â€”', hl:false},
         {ln:9, code:'N â† 0', hl:false},
         {ln:10, code:'for (i â† 0; i < k; i++)', hl:false},
         {ln:11, code:'  y[i] â† SamplePolyCBD_Î·â‚(PRF(r, N)); N++', hl:true, cm:'// ephemeral vector'},
         {ln:12, code:'for (i â† 0; i < k; i++)', hl:false},
         {ln:13, code:'  eâ‚[i] â† SamplePolyCBD_Î·â‚‚(PRF(r, N)); N++', hl:true},
         {ln:14, code:'eâ‚‚ â† SamplePolyCBD_Î·â‚‚(PRF(r, N))', hl:true, cm:'// scalar polynomial'},
       ]},
      {name:"NTT (Number Theoretic Transform) of Ephemeral",
       math:"Å·[i] = NTT(y[i])   âˆ€i",
       desc:"Implementation: same 7-layer butterfly as keygen NTT, applied to k polynomials of y. Produces Å· in evaluation domain for the matrix-vector multiply and inner product steps that follow. eâ‚ and eâ‚‚ remain in coefficient domain â€” they are added after INTT. Security: the ephemeral vector y must be zeroized immediately after use along with all other encapsulation intermediates. If y leaks (e.g., via cold-boot attack or memory dump), an attacker can compute u âˆ’ Aáµ€y = eâ‚ and v âˆ’ táµ€y âˆ’ eâ‚‚ to recover m directly, bypassing the M-LWE problem entirely. The NTT of y is equally sensitive.",
       color:"#a78bfa",type:"transform",
       algRef:"Alg 14 line 20",
       pseudo:[
         {ln:20, code:'for (i â† 0; i < k; i++)', hl:false},
         {ln:'', code:'  Å·[i] â† NTT(y[i])', hl:true},
       ]},
      {name:"Compute u",
       math:"u = NTTâ»Â¹(Ã‚áµ€ âˆ˜ Å·) + eâ‚",
       desc:"Implementation: regenerate Ã‚ from Ï (stored in ek). Transpose access: Ã‚áµ€[i][j] = Ã‚[j][i]. Multiply via MultiplyNTTs (Alg 11), accumulate k products per row, then INTT (Alg 10, 7-layer inverse butterfly with Î¶â»Â¹=1175, final multiply by 128â»Â¹=3303 mod q). Add eâ‚ coefficient-wise. Result u has coefficients in [0, q). Security: u = Aáµ€y + eâ‚ creates a second M-LWE instance independent of the keygen instance t = As + e. The transpose Aáµ€ ensures the encapsulator's ephemeral secret y cannot be trivially related to the static secret s. The error eâ‚ with Î·â‚‚=2 is essential â€” without it, u would be exactly Aáµ€y, and an adversary with the public key could recover y via linear algebra, then compute táµ€y and extract m from v.",
       color:"#f87171",type:"compute",
       algRef:"Alg 14 line 21",
       pseudo:[
         {ln:21, code:'u â† NTTâ»Â¹(Ã‚áµ€ âˆ˜ Å·) + eâ‚', hl:true, cm:'// Ã‚ rebuilt from Ï in ek'},
       ]},
      {name:"Compress u",
       math:"câ‚ = ByteEncode_du(Compress_du(u))",
       desc:"Implementation: Compress_du(x) = âŒˆ(2^du / q) Â· xâŒ‹ mod 2^du for each coefficient. du=10 (ML-KEM-768): maps [0,3328] â†’ [0,1023], introduces rounding error â‰¤ q/(2^11) â‰ˆ 1.6. ByteEncode packs du-bit values: 10-bit â†’ 5 bytes per 4 coefficients. Output size: 32Â·duÂ·k bytes (ML-KEM-768: 960 bytes). du=11 for ML-KEM-1024. Security: compression is a deliberate lossy operation that trades ciphertext size for decryption noise. The rounding error is permanent and contributes to the total noise budget. Importantly, compression also serves a security function: it destroys the exact algebraic relationship between u and y, making certain lattice reduction attacks harder because the adversary only sees an approximate version of Aáµ€y + eâ‚. The du parameter is chosen so compression noise stays well within the correctness bound while minimizing bandwidth.",
       color:"#38bdf8",type:"compress",
       algRef:"Alg 14 line 23",
       pseudo:[
         {ln:23, code:'câ‚ â† ByteEncode_du(Compress_du(u))', hl:true, cm:'// lossy: 12-bit â†’ du-bit'},
       ]},
      {name:"Compute v",
       math:"v = NTTâ»Â¹(tÌ‚áµ€ âˆ˜ Å·) + eâ‚‚ + Decompressâ‚(m)",
       desc:"Implementation: decode tÌ‚ from ek via ByteDecodeâ‚â‚‚. Inner product tÌ‚áµ€âˆ˜Å· = Î£ tÌ‚[i]âˆ˜Å·[i] (k MultiplyNTTs + accumulate), then INTT. Add eâ‚‚ coefficient-wise. Decompressâ‚(m): for each bit b of m, output bÂ·âŒˆq/2âŒ‹ = bÂ·1665. This places message bits at maximum distance from the rounding boundary q/4 â‰ˆ 832. Security: encoding m at the midpoint âŒˆq/2âŒ‹ is a standard technique from Regev's original LWE encryption â€” it maximizes the noise tolerance by placing the two symbols (0 and âŒˆq/2âŒ‹) as far apart as possible in â„¤_q. The error eâ‚‚ prevents v from being an exact function of the public values (t, y) and the message m, which would allow a key-recovery attack via the relation v âˆ’ táµ€y âˆ’ Decompressâ‚(m) = eâ‚‚.",
       color:"#f87171",type:"compute",
       algRef:"Alg 14 line 22",
       pseudo:[
         {ln:22, code:'Âµ â† Decompressâ‚(ByteDecodeâ‚(m))', hl:false, cm:'// 0â†’0, 1â†’1665'},
         {ln:'', code:'v â† NTTâ»Â¹(tÌ‚áµ€ âˆ˜ Å·) + eâ‚‚ + Âµ', hl:true},
       ]},
      {name:"Compress v",
       math:"câ‚‚ = ByteEncode_dv(Compress_dv(v))",
       desc:"Implementation: Compress_dv(x) = âŒˆ(2^dv / q) Â· xâŒ‹ mod 2^dv. dv=4 (ML-KEM-768): maps [0,3328] â†’ [0,15], aggressive 12â†’4 bit reduction. Rounding error â‰¤ q/(2^5) â‰ˆ 104. Combined noise budget: |eáµ€y + eâ‚‚ âˆ’ sáµ€eâ‚| + compress(u) error + compress(v) error must stay < q/4 = 832. Output: 32Â·dv bytes (ML-KEM-768: 128 bytes). dv=5 for ML-KEM-1024. Security: v compression is the most aggressive step â€” dv=4 discards 8 bits per coefficient. This is where the correctness-security tradeoff is tightest. If dv were smaller (more aggressive), the compression noise could push total error past q/4, causing decryption failures. Decryption failures are a security concern: Guo-Johansson-Stebila showed that an adversary who can observe whether decapsulation fails can mount a key-recovery attack in ~2Â²â° queries for certain failure rates. ML-KEM's parameters ensure failure probability â‰ˆ 2â»Â¹â¶â´, making this attack infeasible.",
       color:"#38bdf8",type:"compress",
       algRef:"Alg 14 line 24",
       pseudo:[
         {ln:24, code:'câ‚‚ â† ByteEncode_dv(Compress_dv(v))', hl:true, cm:'// aggressive: 12â†’dv bit'},
       ]},
      {name:"Output Ciphertext & Key",
       math:"c = (câ‚ â€– câ‚‚)    K = SHA3-256(KÌ„)",
       desc:"Implementation: concatenate câ‚ (32Â·duÂ·k bytes) and câ‚‚ (32Â·dv bytes). Ciphertext sizes: ML-KEM-512: 768 B, ML-KEM-768: 1088 B, ML-KEM-1024: 1568 B. Shared secret K = SHA3-256(KÌ„) where KÌ„ = G(m â€– H(ek))[0..31]. K is the 32-byte key for subsequent AEAD (e.g., AES-256-GCM). Zeroize m, KÌ„, r, y, eâ‚, eâ‚‚ after use. Security: the final SHA3-256 hash of KÌ„ provides a clean pseudorandom 256-bit shared secret even if KÌ„ has minor structural biases from the G derivation. Immediate zeroization of ephemeral values is critical â€” if m persists in memory, an attacker who compromises the encapsulator after the protocol completes can recompute K. This is the 'forward secrecy' concern: each encapsulation should use fresh m from the RBG, and ephemeral state should not survive the operation.",
       color:"#f59e0b",type:"output",
       algRef:"Alg 14 line 25, Alg 17 lines 2-3",
       pseudo:[
         {ln:25, code:'c â† câ‚ â€– câ‚‚', hl:false, cm:'// Alg 14: ciphertext'},
         {ln:'', code:'â€” ML-KEM wrapper (Alg 17) â€”', hl:false},
         {ln:2, code:'c â† K-PKE.Encrypt(ek, m, r)', hl:false},
         {ln:3, code:'K â† SHA3-256(KÌ„)', hl:true, cm:'// shared secret from G output'},
         {ln:4, code:'return (K, c)', hl:false},
       ]},
    ],
  },
  {
    id:"decaps", label:"DECAPSULATE", color:"#34d399",
    alg:"Alg 15: K-PKE.Decrypt(dk,c) + Alg 18: ML-KEM.Decaps_internal(dk,c)",
    flows:[
      {from:0,to:1,label:"câ‚, câ‚‚ raw",type:"seq"},
      {from:1,to:2,label:"u' approx",type:"seq"},
      {from:1,to:4,label:"v' approx",type:"data"},
      {from:2,to:3,label:"Ã»' NTT",type:"seq"},
      {from:3,to:4,label:"Åáµ€Â·Ã»'",type:"seq"},
      {from:4,to:5,label:"â‰ˆâŒˆq/2âŒ‹m+Îµ",type:"seq"},
      {from:5,to:6,label:"m' bits",type:"seq"},
      {from:6,to:7,label:"pass/fail",type:"seq"},
    ],
    loops:[
      {from:6,to:0,label:"FO: re-encrypt m'â†’c*, compare c*â‰Ÿc",color:"#e879f9",desc:"Fujisaki-Okamoto (FOâŠ¥â‚˜) implicit rejection: deterministically re-run K-PKE.Encrypt(ek, m', r') with noise re-derived from m' via G(m' â€– H(ek)) â†’ (KÌ„', r') â†’ PRF(r', N++). If c*â‰ c, ciphertext was tampered (chosen-ciphertext attack). Output pseudorandom KÌ„=J(zâ€–c) via SHAKE-256 â€” attacker cannot distinguish real from rejection KÌ„. This converts CPAâ†’CCA2 security. Without this check, Bleichenbacher-style adaptive attacks on the ciphertext allow key recovery. Constant-time comparison and branch-free selection are mandatory to prevent timing oracles."},
    ],
    layers:[
      {name:"Receive Ciphertext",
       math:"c = (câ‚, câ‚‚)",
       desc:"Implementation: parse dk into four fields at fixed offsets â€” dkPKE = dk[0 : 384k], ek = dk[384k : 768k+32], h = dk[768k+32 : 768k+64] (precomputed H(ek)), z = dk[768k+64 : 768k+96] (rejection seed). Parse ciphertext c into câ‚ = c[0 : 32Â·duÂ·k] and câ‚‚ = c[32Â·duÂ·k :]. All offsets are compile-time constants per parameter set. Security: the decapsulation key must be stored in secure memory with access controls â€” it contains the long-term secret Å (in dkPKE), the rejection seed z, and the cached H(ek). An attacker with dk can compute all shared secrets for any ciphertext. FIPS 203 mandates that dk is generated and stored in a FIPS 140-3 validated cryptographic module. Input validation: implementations should verify ciphertext length before parsing to prevent buffer overflows.",
       color:"#94a3b8",type:"input",
       algRef:"Alg 18 input, Alg 15 line 1",
       pseudo:[
         {ln:1, code:'Input: dk (decapsulation key), c (ciphertext)', hl:false},
         {ln:'', code:'â€” Parse dk components â€”', hl:false},
         {ln:2, code:'dkPKE â† dk[0:384k]', hl:false},
         {ln:3, code:'ek â† dk[384k:768k+32]', hl:false},
         {ln:4, code:'h â† dk[768k+32:768k+64]', hl:false, cm:'// H(ek) stored at keygen'},
         {ln:5, code:'z â† dk[768k+64:768k+96]', hl:false, cm:'// rejection seed'},
       ]},
      {name:"Decompress",
       math:"u' = Decompress_du(ByteDecode_du(câ‚))    v' = Decompress_dv(ByteDecode_dv(câ‚‚))",
       desc:"Implementation: ByteDecode_du unpacks du-bit values from byte array. Decompress_du(x) = âŒˆ(q / 2^du) Â· xâŒ‹ = (q Â· x + 2^(du-1)) >> du. Introduces permanent additive error |Îµ| â‰¤ âŒˆq / 2^(du+1)âŒ‰. For du=10: error â‰¤ 2. For dv=4: error â‰¤ 104. These errors accumulate with the LWE noise but remain within the correctness bound. Security: decompression is applied to untrusted data (the ciphertext comes from the network). Implementations must ensure Decompress produces values in [0, q) for all inputs in [0, 2^d) â€” out-of-range coefficients could cause modular arithmetic errors that leak information about the secret key. This is a known attack vector: Bauer-Iglesias showed that malformed ciphertexts with out-of-range coefficients can induce side-channel leakage in some implementations.",
       color:"#38bdf8",type:"compress",
       algRef:"Alg 15 lines 2-5",
       pseudo:[
         {ln:2, code:'câ‚ â† c[0:32Â·duÂ·k]', hl:false},
         {ln:3, code:'câ‚‚ â† c[32Â·duÂ·k:]', hl:false},
         {ln:4, code:"u' â† Decompress_du(ByteDecode_du(câ‚))", hl:true, cm:'// [0,2^du) â†’ [0,q)'},
         {ln:5, code:"v' â† Decompress_dv(ByteDecode_dv(câ‚‚))", hl:true},
       ]},
      {name:"NTT (Number Theoretic Transform) of u'",
       math:"Ã»' = NTT(u')",
       desc:"Implementation: apply forward NTT (Alg 9) to each of k polynomials in u'. Required because Å is stored in NTT domain from keygen â€” both operands must be in the same domain for pointwise multiplication. 7 Ã— 128 Ã— k multiply-reduce operations. Security: the NTT here operates on attacker-controlled data (decompressed ciphertext). While the NTT itself is a public linear transform, implementations must ensure constant-time execution â€” variable-time reduction mod q on attacker-chosen inputs could leak timing information about intermediate values that correlate with the secret key in the subsequent multiplication step.",
       color:"#a78bfa",type:"transform",
       algRef:"Alg 15 (implicit in line 6)",
       pseudo:[
         {ln:'', code:"for (i â† 0; i < k; i++)", hl:false},
         {ln:'', code:"  Ã»'[i] â† NTT(u'[i])", hl:true},
       ]},
      {name:"Secret Â· Ciphertext",
       math:"w = NTTâ»Â¹(Åáµ€ âˆ˜ Ã»')",
       desc:"Implementation: decode Å from dkPKE via ByteDecodeâ‚â‚‚ (384 bytes per polynomial â†’ 256 12-bit coefficients). Inner product: Î£ Å[i] âˆ˜ Ã»'[i] using MultiplyNTTs (k Ã— 128 base-case multiplies), accumulate, then INTT. Result w â‰ˆ sáµ€(Aáµ€y + eâ‚) = sáµ€Aáµ€y + sáµ€eâ‚ + compression noise. Security: this is the most sensitive computation in decapsulation â€” it directly multiplies the long-term secret Å with attacker-controlled data Ã»'. Power analysis (DPA/SPA), electromagnetic emanation, and cache-timing attacks on this multiplication are the primary implementation-level threat. All MultiplyNTTs base-case operations must be constant-time: no branching on coefficient values, no variable-time Barrett/Montgomery reduction, no data-dependent memory access patterns.",
       color:"#f87171",type:"compute",
       algRef:"Alg 15 line 6",
       pseudo:[
         {ln:6, code:"Å â† ByteDecodeâ‚â‚‚(dkPKE)", hl:false, cm:'// recover NTT-domain secret'},
         {ln:7, code:"w â† NTTâ»Â¹(Åáµ€ âˆ˜ Ã»')", hl:true, cm:'// inner product + INTT'},
       ]},
      {name:"Subtract & Isolate",
       math:"mÌƒ = v' âˆ’ w  â‰ˆ  âŒˆq/2âŒ‹Â·m + Îµ_total",
       desc:"Implementation: coefficient-wise subtraction mod q (if result < 0, add q). Algebraically: v' âˆ’ w â‰ˆ (táµ€y + eâ‚‚ + âŒˆq/2âŒ‹m) âˆ’ (sáµ€Aáµ€y + sáµ€eâ‚). Since t = As + e, táµ€y = sáµ€Aáµ€y + eáµ€y, so the sáµ€Aáµ€y terms cancel. Remainder: âŒˆq/2âŒ‹Â·m + (eáµ€y + eâ‚‚ âˆ’ sáµ€eâ‚) + compression noise. All noise coefficients are bounded by the parameter-set-specific Î´. Security: the key cancellation property is the mathematical heart of LWE-based encryption â€” it relies on the fact that both parties can independently compute sáµ€Aáµ€y (the keygen party via s directly, the encryption party via the public key t = As + e). The residual noise Îµ = eáµ€y + eâ‚‚ âˆ’ sáµ€eâ‚ is a sum of products of small-coefficient polynomials, and its magnitude is statistically bounded. An adversary who does not know s cannot compute w, so they cannot isolate the message from v.",
       color:"#f87171",type:"compute",
       algRef:"Alg 15 line 7 (partial)",
       pseudo:[
         {ln:7, code:"mÌƒ â† v' âˆ’ w", hl:true, cm:'// â‰ˆ âŒˆq/2âŒ‹Â·m + small noise'},
       ]},
      {name:"Decode Message",
       math:"m' = Compressâ‚(mÌƒ):  m'[i] = âŒˆ(2/q)Â·mÌƒ[i]âŒ‹ mod 2",
       desc:"Implementation: Compressâ‚(x) = ((x << 1) + q/2) / q & 1, or equivalently test whether x is closer to 0 or to âŒˆq/2âŒ‹ = 1665. Decision boundary at q/4 â‰ˆ 832. For ML-KEM-768, max |Îµ_total| is bounded such that decryption failure probability â‰ˆ 2â»Â¹â¶â´. Output: 32 bytes (256 bits). Security: the decryption failure probability (DFP) is a critical security parameter, not just a correctness concern. D'Anvers-Guo-Johansson-Stebila-Nilsson showed that decryption failures leak information about the secret key â€” an adversary who can detect failures (e.g., by observing whether a TLS handshake succeeds) can mount adaptive chosen-ciphertext attacks to recover s in roughly 2^(DFP_exponent) queries. ML-KEM's DFP of 2â»Â¹â¶â´ makes this attack require more queries than the security level, rendering it infeasible. The implicit rejection mechanism (next steps) provides additional defense.",
       color:"#34d399",type:"decode",
       algRef:"Alg 15 line 7",
       pseudo:[
         {ln:7, code:"m' â† ByteEncodeâ‚(Compressâ‚(mÌƒ))", hl:true, cm:'// round to {0,1} per coeff'},
       ]},
      {name:"FO Re-Encrypt & Compare",
       math:"(KÌ„', r') â† G(m' â€– h);  c' â† K-PKE.Encrypt(ek, m', r');  c' â‰Ÿ c",
       desc:"Implementation: recompute (KÌ„', r') = SHA3-512(m' â€– h) using stored h = H(ek). Re-run full K-PKE.Encrypt: regenerate Ã‚ from Ï, re-sample y,eâ‚,eâ‚‚ from r' via PRF, compute u',v', compress. Constant-time byte comparison of c' vs c (no early exit). If mismatch: KÌ„ = SHAKE-256(z â€– c) using secret rejection seed z. Both paths must execute in constant time to prevent timing oracles. Security: this is the Fujisaki-Okamoto (FOâŠ¥â‚˜) transform â€” it upgrades K-PKE from IND-CPA to IND-CCA2. Without it, the scheme would be vulnerable to chosen-ciphertext attacks: an adversary could modify a valid ciphertext, submit it for decapsulation, and learn about m from the resulting shared secret. The re-encryption check detects any ciphertext tampering. Implicit rejection (outputting pseudorandom K from z rather than âŠ¥) prevents Bleichenbacher-style oracles: the adversary cannot distinguish valid from invalid ciphertexts, eliminating adaptive attacks that exploit decapsulation failure signals in protocols like TLS.",
       color:"#e879f9",type:"verify",
       algRef:"Alg 18 lines 6-9",
       pseudo:[
         {ln:6, code:"(KÌ„', r') â† G(m' â€– h)", hl:true, cm:'// re-derive noise coin'},
         {ln:7, code:"KÌ„ â† SHA3-256(KÌ„')", hl:false, cm:'// candidate shared secret'},
         {ln:8, code:"c' â† K-PKE.Encrypt(ek, m', r')", hl:true, cm:'// full re-encryption'},
         {ln:9, code:'if c â‰  c\':', hl:false},
         {ln:10, code:'  KÌ„ â† J(z â€– c)', hl:true, cm:'// J = SHAKE-256: implicit rejection'},
       ]},
      {name:"Shared Secret Output",
       math:"K = KÌ„  (either SHA3-256(KÌ„') if match, or J(zâ€–c) if reject)",
       desc:"Implementation: conditional assignment KÌ„ = ct_select(SHA3-256(KÌ„'), SHAKE-256(z â€– c), match_flag) must use constant-time select (e.g., bitwise mask from comparison result). Output KÌ„ as the 32-byte shared secret. Zeroize all intermediate values: m', KÌ„', r', c', Å, z. The adversary gains zero information about which branch was taken â€” this provides IND-CCA2 security per FOâŠ¥â‚˜ transform proof. Security: the rejection key J(z â€– c) is deterministic in c â€” if the same malformed ciphertext is submitted twice, the same rejection key is produced. This prevents an adversary from using randomness in the rejection output as a side-channel. Including c in the rejection hash ensures different malformed ciphertexts produce independent-looking keys, preventing cross-ciphertext correlation attacks. The secret seed z must have been generated at keygen time with full 256-bit entropy and never exposed â€” if z leaks, the adversary can distinguish rejection from acceptance.",
       color:"#34d399",type:"output",
       algRef:"Alg 18 lines 10-11",
       pseudo:[
         {ln:10, code:'return KÌ„', hl:true, cm:'// 32-byte shared secret'},
         {ln:'', code:'', hl:false},
         {ln:'', code:'// Caller uses KÌ„ for AEAD keying', hl:false},
         {ln:'', code:'// zâ€–c rejection is indistinguishable', hl:false},
       ]},
    ],
  },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LAYER SUMMARIES â€” plain-language one-liners for 3D cards
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SUMMARIES = {
  keygen: [
    "Hash one 32-byte seed into two independent sub-seeds (Ï, Ïƒ) via SHA3-512",
    "Expand Ï into a kÃ—k matrix of degree-255 polynomials mod q = 3329",
    "Sample k secret polynomials with small random coefficients in [âˆ’Î·â‚, Î·â‚]",
    "Sample k noise polynomials from the same small-coefficient distribution",
    "Apply forward NTT to convert s and e from coefficient form to evaluation form",
    "Compute Ã‚Â·Å â€” kÂ² pointwise polynomial multiplications in NTT domain",
    "Add Ãª to get tÌ‚ = Ã‚Â·Å + Ãª â€” this is the Module-LWE public key vector",
    "Serialize public key (tÌ‚, Ï) and private key (Å, ek, H(ek), z) to byte arrays",
  ],
  encaps: [
    "Draw 32 random bytes m â€” the ephemeral seed for all encryption randomness",
    "SHA3-512(m â€– H(ek)) â†’ shared secret material KÌ„ + deterministic noise coin r",
    "Forward NTT on ephemeral vector y for efficient polynomial multiplication",
    "u = NTTâ»Â¹(Ã‚áµ€Â·Å·) + eâ‚ â€” matrix-vector multiply plus noise in coefficient domain",
    "Lossy-round u from 12-bit to du-bit coefficients (compress to save bandwidth)",
    "v = NTTâ»Â¹(tÌ‚áµ€Â·Å·) + eâ‚‚ + âŒˆq/2âŒ‹Â·m â€” inner product plus encoded message bits",
    "Lossy-round v from 12-bit to dv-bit (most aggressive compression step)",
    "Output ciphertext c = (câ‚ â€– câ‚‚) and shared secret K = SHA3-256(KÌ„)",
  ],
  decaps: [
    "Parse ciphertext into compressed components câ‚, câ‚‚ and extract dk fields",
    "Decompress: scale values from [0, 2^d) back to approximate [0, q) representation",
    "Forward NTT on decompressed uâ€² to match the stored NTT-domain secret Å",
    "Inner product w = NTTâ»Â¹(Åáµ€Â·Ã»â€²) â€” approximates the shared lattice point",
    "vâ€² âˆ’ w cancels shared terms, isolating âŒˆq/2âŒ‹Â·m + small residual noise Îµ",
    "Round each coefficient to {0,1} â€” noise is bounded below q/4 so no bits flip",
    "Re-encrypt mâ€² deterministically and compare câ€² â‰Ÿ c (Fujisaki-Okamoto check)",
    "Output K = SHA3-256(KÌ„â€²) if match, or K = SHAKE-256(z â€– c) if reject",
  ],
};

// Inject summaries into layer data
PHASES.forEach(p => p.layers.forEach((l, i) => { l.summary = SUMMARIES[p.id][i]; }));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let currentPhase = "keygen";
let selectedIdx = 0;
let phaseData = PHASES[0];
let showPseudo = true;

function getPhase() { return PHASES.find(p => p.id === currentPhase); }
function setPhase(id) {
  currentPhase = id;
  selectedIdx = 0;
  phaseData = getPhase();
  rebuild();
}
function setSelected(i) {
  selectedIdx = Math.max(0, Math.min(i, phaseData.layers.length - 1));
  rebuild();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HEADER + TABS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderHeader() {
  const layer = phaseData.layers[selectedIdx];
  document.getElementById('hdr-idx').textContent = String(selectedIdx+1).padStart(2,'0');
  document.getElementById('hdr-idx').style.color = phaseData.color;
  document.getElementById('hdr-count').textContent = ' / ' + phaseData.layers.length;
  document.getElementById('hdr-name').textContent = layer.name;
  document.getElementById('hdr-name').style.color = layer.color;
  document.getElementById('fc-count').textContent = phaseData.layers.length;

  // Tabs
  const tabs = document.getElementById('phase-tabs');
  tabs.innerHTML = '';
  PHASES.forEach((p, pi) => {
    const btn = document.createElement('button');
    btn.className = 'phase-tab' + (p.id === currentPhase ? ' active' : '');
    btn.style.color = p.id === currentPhase ? p.color : '';
    btn.style.borderColor = p.id === currentPhase ? p.color + '30' : 'transparent';
    btn.innerHTML = `<span class="num">${pi+1}</span>${p.label}`;
    btn.onclick = () => setPhase(p.id);
    tabs.appendChild(btn);
  });

  // Pseudocode toggle
  const pcBtn = document.getElementById('pc-toggle');
  pcBtn.className = 'pc-toggle' + (showPseudo ? ' active' : '');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SVG FLOWCHART SIDEBAR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderFlowchart() {
  const wrap = document.getElementById('flowchart-wrap');
  const layers = phaseData.layers;
  const W = 360, padX = 12, nodeH = 34, gapY = 12, nodeX = padX + 14;
  const nodeW = W - padX*2 - 28;
  const totalH = layers.length * (nodeH + gapY) + 60;
  const getY = i => 22 + i * (nodeH + gapY);
  const getCY = i => getY(i) + nodeH / 2;

  let svg = `<svg width="${W}" height="${totalH}" xmlns="http://www.w3.org/2000/svg">`;
  svg += `<defs>`;
  layers.forEach((l, i) => {
    svg += `<linearGradient id="lg${i}" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="${l.color}" stop-opacity="${selectedIdx===i?'0.2':'0.12'}"/><stop offset="100%" stop-color="${l.color}" stop-opacity="0.03"/></linearGradient>`;
  });
  svg += `<marker id="am" viewBox="0 0 8 8" refX="7" refY="4" markerWidth="8" markerHeight="8" orient="auto"><path d="M0 1L7 4L0 7Z" fill="#b0bec5"/></marker>`;
  svg += `<marker id="amc" viewBox="0 0 8 8" refX="7" refY="4" markerWidth="8" markerHeight="8" orient="auto"><path d="M0 1L7 4L0 7Z" fill="#e879f9"/></marker>`;
  svg += `</defs>`;

  // Sequential flows
  phaseData.flows.filter(f => f.type==="seq" && f.to===f.from+1).forEach(f => {
    const y1 = getY(f.from) + nodeH + 1;
    const y2 = getY(f.to) - 1;
    const mx = nodeX + nodeW/2;
    const fc = layers[f.from].color;
    svg += `<line x1="${mx}" y1="${y1}" x2="${mx}" y2="${y2}" stroke="${fc}" stroke-width="2" stroke-opacity="0.8" marker-end="url(#am)"/>`;
    svg += `<text x="${mx+10}" y="${(y1+y2)/2+3}" font-size="8" font-family="'Courier New',monospace" fill="${fc}" fill-opacity="0.9">${f.label}</text>`;
  });

  // Non-sequential / data flows
  let dataFlowIdx = 0;
  phaseData.flows.filter(f => !(f.type==="seq" && f.to===f.from+1)).forEach(f => {
    const fromY = getCY(f.from);
    const toY = getCY(f.to);
    const isLeft = dataFlowIdx % 2 === 0;
    const side = isLeft ? nodeX - 4 : nodeX + nodeW + 4;
    const gap = f.to - f.from;
    const bulge = isLeft ? nodeX - 20 - gap*4 : nodeX + nodeW + 20 + gap*4;
    const fc = layers[f.from].color;
    const midY = (fromY + toY) / 2;
    svg += `<path d="M${side} ${fromY} C${bulge} ${fromY},${bulge} ${toY},${side} ${toY}" fill="none" stroke="${fc}" stroke-width="1.8" stroke-opacity="0.85" stroke-dasharray="5,2" marker-end="url(#am)"/>`;
    svg += `<text x="${bulge+(isLeft?-3:3)}" y="${midY+3}" font-size="8" font-family="'Courier New',monospace" fill="${fc}" fill-opacity="1" text-anchor="${isLeft?'end':'start'}">${f.label}</text>`;
    dataFlowIdx++;
  });

  // Loop-back arcs
  phaseData.loops.forEach(loop => {
    const fromY = getCY(loop.from);
    const toY = getCY(loop.to);
    const rx = nodeX + nodeW + 40;
    svg += `<path d="M${nodeX+nodeW+4} ${fromY} C${rx+12} ${fromY},${rx+12} ${toY},${nodeX+nodeW+4} ${toY}" fill="none" stroke="${loop.color}" stroke-width="2.2" stroke-opacity="0.9" stroke-dasharray="5,3" marker-end="url(#amc)"/>`;
    svg += `<text x="${rx+6}" y="${(fromY+toY)/2}" font-size="8" font-family="'Courier New',monospace" fill="${loop.color}" fill-opacity="1" text-anchor="start" writing-mode="tb">â†º FO loop</text>`;
  });

  // Nodes
  layers.forEach((l, i) => {
    const y = getY(i);
    const isSel = i === selectedIdx;
    svg += `<g class="fc-node" onclick="setSelected(${i})">`;
    svg += `<rect x="${nodeX}" y="${y}" width="${nodeW}" height="${nodeH}" rx="4" fill="url(#lg${i})" stroke="${l.color}" stroke-width="${isSel?1.5:0.5}" stroke-opacity="${isSel?1:0.3}"/>`;
    svg += `<rect x="${nodeX}" y="${y}" width="3" height="${nodeH}" rx="1" fill="${l.color}" opacity="${isSel?1:0.3}"/>`;
    svg += `<text x="${nodeX+10}" y="${y+13}" font-size="8" font-family="'Courier New',monospace" fill="${l.color}" opacity="${isSel?1:0.5}">${String(i+1).padStart(2,'0')}</text>`;
    svg += `<text x="${nodeX+26}" y="${y+13}" font-size="9.5" font-family="'Segoe UI',sans-serif" font-weight="${isSel?'bold':'normal'}" fill="${isSel?l.color:'#8896a6'}">${l.name}</text>`;
    const mathTrunc = l.math.length > 40 ? l.math.slice(0,40)+'â€¦' : l.math;
    svg += `<text x="${nodeX+10}" y="${y+27}" font-size="8" font-family="'Courier New',monospace" fill="${isSel?'#cbd5e1':'#475569'}">${escHtml(mathTrunc)}</text>`;
    svg += `</g>`;
  });

  svg += `</svg>`;
  wrap.innerHTML = svg;

  requestAnimationFrame(() => {
    const node = wrap.querySelectorAll('.fc-node')[selectedIdx];
    if (node) node.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  });
}

function escHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PSEUDOCODE PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderPseudocode() {
  const el = document.getElementById('pseudocode');
  const inner = document.getElementById('pc-inner');
  el.className = showPseudo ? 'open' : '';
  if (!showPseudo) return;

  const layer = phaseData.layers[selectedIdx];
  if (!layer.pseudo || !layer.pseudo.length) {
    inner.innerHTML = `<div class="pc-title">PSEUDOCODE <span class="pc-ref">${layer.algRef || ''}</span></div><div class="pc-code" style="color:var(--textdark)">No pseudocode for this layer</div>`;
    return;
  }

  let html = `<div class="pc-title">PSEUDOCODE <span class="pc-ref">Â· FIPS 203 ${layer.algRef || ''}</span></div>`;
  html += `<div class="pc-code">`;
  layer.pseudo.forEach(p => {
    const lnStr = p.ln !== '' && p.ln !== undefined ? String(p.ln).padStart(2,' ') : '  ';
    const cmStr = p.cm ? ` <span class="pc-cm">${escHtml(p.cm)}</span>` : '';
    if (p.hl) {
      html += `<div><span class="pc-ln">${lnStr}</span><span class="pc-hl">${escHtml(p.code)}</span>${cmStr}</div>`;
    } else {
      html += `<div><span class="pc-ln">${lnStr}</span>${escHtml(p.code)}${cmStr}</div>`;
    }
  });
  html += `</div>`;
  inner.innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DETAIL PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderDetail() {
  const el = document.getElementById('detail');
  const layer = phaseData.layers[selectedIdx];
  el.style.background = layer.color + '08';

  const incoming = (phaseData.flows||[]).filter(f => f.to === selectedIdx);
  const outgoing = (phaseData.flows||[]).filter(f => f.from === selectedIdx);
  const loop = (phaseData.loops||[]).find(l => l.from === selectedIdx);

  let html = `<div class="det-header"><div class="det-dot" style="background:${layer.color}"></div><span class="det-name" style="color:${layer.color}">${layer.name}</span>`;
  if (layer.algRef) html += `<span class="det-alg">${layer.algRef}</span>`;
  html += `<span class="det-type">${layer.type}</span></div>`;
  html += `<div class="det-math" style="border-color:${layer.color}20">${escHtml(layer.math)}</div>`;
  html += `<div class="det-desc">${layer.desc}</div>`;

  if (incoming.length || outgoing.length) {
    html += `<div class="flow-links" style="border-top:1px solid ${layer.color}15">`;
    if (incoming.length) {
      html += `<div style="margin-bottom:4px"><span class="fl-label">â† IN: </span>`;
      incoming.forEach(f => {
        const fc = phaseData.layers[f.from].color;
        html += `<span class="fl-badge" onclick="setSelected(${f.from})" style="color:${fc};background:${fc}15;border:1px solid ${fc}30">${escHtml(f.label)} â† ${String(f.from+1).padStart(2,'0')}</span>`;
      });
      html += `</div>`;
    }
    if (outgoing.length) {
      html += `<div><span class="fl-label">â†’ OUT: </span>`;
      outgoing.forEach(f => {
        const tc = phaseData.layers[f.to].color;
        html += `<span class="fl-badge" onclick="setSelected(${f.to})" style="color:${tc};background:${tc}15;border:1px solid ${tc}30">${escHtml(f.label)} â†’ ${String(f.to+1).padStart(2,'0')}</span>`;
      });
      html += `</div>`;
    }
    html += `</div>`;
  }

  if (loop) {
    html += `<div class="loop-box" style="background:${loop.color}10;border:1px solid ${loop.color}25"><div class="loop-title" style="color:${loop.color}">â†º ITERATION LOOP</div><div class="loop-desc">${loop.desc}</div></div>`;
  }

  el.innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THREE.JS 3D SCENE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let scene, camera, renderer, clock;
let camAngle = { theta: 0.45, phi: 0.55 };
let camAngleTarget = { theta: 0.45, phi: 0.55 };
let camTargetY = 0;
let isDrag = false, dragStart = { x:0, y:0 };
let camDist = 9;
const SPACING = 2.6, SLAB_W = 6.8, SLAB_H = 0.09, SLAB_D = 3.0;

function makeCanvasTex(drawFn, w, h) {
  const S = 2, c = document.createElement('canvas');
  c.width = w*S; c.height = h*S;
  const ctx = c.getContext('2d');
  ctx.scale(S, S);
  drawFn(ctx, w, h);
  const t = new THREE.CanvasTexture(c);
  t.minFilter = THREE.LinearFilter;
  t.magFilter = THREE.LinearFilter;
  t.anisotropy = 4;
  return t;
}

// Returns final y after last line drawn
function wrapTextCanvas(ctx, text, x, y, maxW, lh, maxLines) {
  const words = text.split(' ');
  let line = '', ly = y, n = 0;
  for (const w of words) {
    const test = line + (line?' ':'')+w;
    if (ctx.measureText(test).width > maxW && line) {
      ctx.fillText(line, x, ly);
      line = w; ly += lh; n++;
      if (maxLines && n >= maxLines) { ctx.fillText(line+'â€¦', x, ly); return ly + lh; }
    } else line = test;
  }
  if (line) { ctx.fillText(line, x, ly); ly += lh; }
  return ly;
}

// Count how many wrapped lines text would need at current ctx.font
function countWrapLines(ctx, text, maxW) {
  const words = text.split(' ');
  let line = '', n = 1;
  for (const w of words) {
    const test = line + (line?' ':'')+w;
    if (ctx.measureText(test).width > maxW && line) { line = w; n++; }
    else line = test;
  }
  return n;
}

// Auto-shrink font from startSz down to minSz until text fits availH, then draw
function fitTextCanvas(ctx, text, x, y, maxW, availH, color, startSz) {
  let sz = startSz || 10;
  const minSz = 7;
  let lh, nLines;
  while (sz >= minSz) {
    ctx.font = sz + 'px sans-serif';
    lh = Math.round(sz * 1.25);
    nLines = countWrapLines(ctx, text, maxW);
    if (nLines * lh <= availH) break;
    sz -= 0.5;
  }
  ctx.font = sz + 'px sans-serif';
  ctx.fillStyle = color;
  const maxL = Math.floor(availH / lh);
  return wrapTextCanvas(ctx, text, x, y, maxW, lh, maxL);
}

function layerTex(layer, isSel) {
  const hasPseudo = isSel && layer.pseudo && layer.pseudo.length > 0;
  const hasSummary = !!layer.summary;
  const CW = 740, mW = CW - 28, pad = 14;

  // â”€â”€ Pre-measure to determine canvas height â”€â”€
  let texH;
  if (!isSel) {
    texH = hasSummary ? 140 : 100;
  } else {
    // Measure with a scratch canvas
    const mc = document.createElement('canvas');
    mc.width = CW; const mx = mc.getContext('2d');
    let h = 28; // name row
    if (hasPseudo) {
      h += 12; // label
      h += Math.min(layer.pseudo.length, 6) * 13;
      if (layer.pseudo.length > 6) h += 10;
      h += 10; // separator
    }
    if (hasSummary) {
      mx.font = 'italic 10px sans-serif';
      h += countWrapLines(mx, 'â–¸ ' + layer.summary, mW) * 12 + 2;
    }
    mx.font = '12px monospace';
    h += countWrapLines(mx, layer.math, mW) * 14 + 4;
    // Desc at 10px target
    mx.font = '10px sans-serif';
    const descLines = countWrapLines(mx, layer.desc, mW);
    let descLh = 12;
    h += descLines * descLh;
    // If it exceeds a cap, shrink font estimate
    if (h > 500) { descLh = 10; h = h - descLines*12 + descLines*10; }
    texH = Math.min(Math.max(h + 10, 160), 500);
  }

  const tex = makeCanvasTex((ctx, W, H) => {
    // â”€â”€ Background â”€â”€
    ctx.fillStyle = isSel ? 'rgba(0,0,0,0.65)' : 'rgba(0,0,0,0.4)';
    ctx.beginPath(); ctx.roundRect(0,0,W,H,5); ctx.fill();
    ctx.fillStyle = layer.color;
    ctx.fillRect(0,0,4,H);
    if (isSel) { ctx.strokeStyle = layer.color; ctx.lineWidth = 2; ctx.beginPath(); ctx.roundRect(1,1,W-2,H-2,5); ctx.stroke(); }
    // â”€â”€ Type badge â”€â”€
    ctx.font = 'bold 9px monospace'; ctx.textAlign = 'right';
    ctx.fillStyle = layer.color+'40';
    const bw = ctx.measureText(layer.type.toUpperCase()).width+14;
    ctx.beginPath(); ctx.roundRect(W-bw-6,6,bw,14,3); ctx.fill();
    ctx.fillStyle = layer.color;
    ctx.fillText(layer.type.toUpperCase(), W-10, 16);
    // â”€â”€ Name â”€â”€
    ctx.textAlign = 'left';
    ctx.font = 'bold 14px sans-serif';
    ctx.fillStyle = layer.color;
    ctx.fillText(layer.name, pad, 18);

    let cur = 28;

    // â•â• PSEUDOCODE AT TOP (selected only) â•â•
    if (hasPseudo) {
      ctx.font = 'bold 8px monospace';
      ctx.fillStyle = layer.color + '80';
      ctx.fillText('PSEUDOCODE Â· FIPS 203 ' + (layer.algRef || ''), pad, cur);
      cur += 12;
      ctx.font = '10px monospace';
      const maxPcLines = 6;
      const pcSlice = layer.pseudo.slice(0, maxPcLines);
      pcSlice.forEach(p => {
        const lnStr = (p.ln !== '' && p.ln !== undefined) ? String(p.ln).padStart(2,' ') : '  ';
        ctx.fillStyle = '#334155';
        ctx.fillText(lnStr, pad, cur);
        if (p.hl) {
          const tw = ctx.measureText(p.code).width;
          ctx.fillStyle = layer.color + '12';
          ctx.fillRect(36, cur - 9, tw + 6, 13);
          ctx.fillStyle = '#e2e8f0';
          ctx.fillText(p.code, 38, cur);
        } else {
          ctx.fillStyle = '#94a3b8';
          ctx.fillText(p.code, 38, cur);
        }
        if (p.cm) {
          const cw = ctx.measureText(p.code).width;
          ctx.fillStyle = '#334155'; ctx.font = 'italic 9px monospace';
          ctx.fillText(p.cm, 42 + cw, cur);
          ctx.font = '10px monospace';
        }
        cur += 13;
      });
      if (layer.pseudo.length > maxPcLines) {
        ctx.fillStyle = '#334155'; ctx.font = 'italic 9px monospace';
        ctx.fillText('â€¦ +' + (layer.pseudo.length - maxPcLines) + ' more', 38, cur);
        cur += 10;
      }
      cur += 3;
      ctx.strokeStyle = layer.color + '30'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(pad, cur); ctx.lineTo(W-pad, cur); ctx.stroke();
      cur += 7;
    }

    // â•â• SUMMARY â•â•
    if (hasSummary) {
      ctx.font = 'italic 10px sans-serif';
      ctx.fillStyle = isSel ? '#b0bec5' : '#6b7a8d';
      cur = wrapTextCanvas(ctx, 'â–¸ ' + layer.summary, pad, cur, mW, 12, 3);
      cur += 2;
    }

    // â•â• MATH FORMULA â•â•
    ctx.font = '12px monospace';
    ctx.fillStyle = isSel ? '#ffffff' : '#cbd5e1';
    cur = wrapTextCanvas(ctx, layer.math, pad, cur, mW, 14, 2);
    cur += 4;

    // â•â• DESCRIPTION â€” auto-scaled to fill remaining canvas â•â•
    if (isSel) {
      const avail = H - cur - 6;
      if (avail > 12) fitTextCanvas(ctx, layer.desc, pad, cur, mW, avail, '#8899aa', 10);
    }
  }, CW, texH);
  return { tex, texH };
}

function flowLabel3D(text, color) {
  return makeCanvasTex((ctx, W, H) => {
    ctx.fillStyle = 'rgba(8,12,20,0.85)';
    ctx.beginPath(); ctx.roundRect(0,0,W,H,3); ctx.fill();
    ctx.strokeStyle = color+'60'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(0,0,W,H,3); ctx.stroke();
    ctx.font = 'bold 9px monospace'; ctx.fillStyle = color;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(text, W/2, H/2);
  }, 180, 18);
}

function clearSceneObjects() {
  while (scene.children.length > 3) scene.remove(scene.children[scene.children.length-1]);
}

function build3D() {
  clearSceneObjects();
  const layers = phaseData.layers;

  // Layer slabs
  layers.forEach((layer, i) => {
    const g = new THREE.Group();
    const isSel = i === selectedIdx;
    const c = new THREE.Color(layer.color);

    const hasPseudo = isSel && layer.pseudo && layer.pseudo.length > 0;
    const hasSummary = !!layer.summary;

    const { tex, texH } = layerTex(layer, isSel);
    // Scale slab depth proportional to canvas height
    const slabD = isSel ? SLAB_D * (texH / 140) : (hasSummary ? SLAB_D * 1.2 : SLAB_D);

    const geo = new THREE.BoxGeometry(SLAB_W, isSel?SLAB_H*2.2:SLAB_H, slabD);
    const mat = new THREE.MeshPhongMaterial({ color: c.clone().multiplyScalar(isSel?0.4:0.18), transparent:true, opacity:isSel?0.88:0.5, specular:c.clone().multiplyScalar(0.3), shininess:50 });
    g.add(new THREE.Mesh(geo, mat));
    g.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color:c, transparent:true, opacity:isSel?0.8:0.25 })));

    const panelD = slabD * 0.92;
    const panel = new THREE.Mesh(new THREE.PlaneGeometry(SLAB_W*0.94, panelD), new THREE.MeshBasicMaterial({ map:tex, transparent:true, opacity:isSel?1:0.85, side:THREE.DoubleSide, depthWrite:false }));
    panel.position.y = (isSel?SLAB_H*1.1:SLAB_H/2)+0.004;
    panel.rotation.x = -Math.PI/2;
    g.add(panel);

    const fTex = makeCanvasTex((ctx, W, H) => {
      ctx.font = 'bold 10px monospace';
      ctx.fillStyle = isSel ? layer.color : '#3e4a5a';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(String(i+1).padStart(2,'0')+'  '+layer.name, W/2, H/2);
    }, 400, 18);
    const fm = new THREE.Mesh(new THREE.PlaneGeometry(SLAB_W*0.85, SLAB_H*1.3), new THREE.MeshBasicMaterial({ map:fTex, transparent:true, opacity:0.9, side:THREE.DoubleSide, depthWrite:false }));
    fm.position.z = slabD/2+0.004;
    g.add(fm);

    if (isSel) {
      const glow = new THREE.Mesh(new THREE.PlaneGeometry(SLAB_W+0.6, slabD+0.6), new THREE.MeshBasicMaterial({ color:c, transparent:true, opacity:0.07, side:THREE.DoubleSide }));
      glow.position.y = -SLAB_H-0.01; glow.rotation.x = -Math.PI/2;
      g.add(glow);
    }

    const orb = new THREE.Mesh(new THREE.SphereGeometry(isSel?0.13:0.06,12,12), new THREE.MeshBasicMaterial({ color:c, transparent:true, opacity:isSel?1:0.4 }));
    orb.position.set(-SLAB_W/2-0.3, 0, 0);
    g.add(orb);

    g.position.y = -i*SPACING;
    scene.add(g);
  });

  // Flow arrows
  (phaseData.flows||[]).forEach((flow, fi) => {
    const y0 = -flow.from*SPACING - SLAB_H/2 - 0.06;
    const y1 = -flow.to*SPACING + SLAB_H/2 + 0.06;
    const isSeq = flow.type==='seq';
    const gap = flow.to - flow.from;
    const isSkip = gap > 1;
    let xOff = 0;
    if (!isSeq || isSkip) xOff = (fi%2===0?-1:1)*(1.5+(isSkip?gap*0.3:0));

    const fromC = new THREE.Color(layers[flow.from].color);
    const toC = new THREE.Color(layers[flow.to].color);
    const midC = fromC.clone().lerp(toC, 0.5);

    const pts = [];
    for (let j=0; j<=24; j++) {
      const t = j/24;
      const y = y0+(y1-y0)*t;
      const bulge = Math.sin(t*Math.PI);
      pts.push(new THREE.Vector3(xOff*bulge, y, (isSkip?-0.3:0)*bulge));
    }
    const curve = new THREE.CatmullRomCurve3(pts);

    const thick = isSeq?0.025:0.018;
    const op = isSeq?0.7:0.5;
    scene.add(new THREE.Mesh(new THREE.TubeGeometry(curve,20,thick,6,false), new THREE.MeshBasicMaterial({ color:midC, transparent:true, opacity:op })));
    scene.add(new THREE.Mesh(new THREE.TubeGeometry(curve,16,thick*3,6,false), new THREE.MeshBasicMaterial({ color:midC, transparent:true, opacity:0.08, blending:THREE.AdditiveBlending, depthWrite:false })));

    const endPt = curve.getPointAt(0.97);
    const prevPt = curve.getPointAt(0.93);
    const dir = new THREE.Vector3().subVectors(endPt, prevPt).normalize();
    const arrow = new THREE.Mesh(new THREE.ConeGeometry(0.06,0.14,5), new THREE.MeshBasicMaterial({ color:midC, transparent:true, opacity:0.85 }));
    arrow.position.copy(endPt);
    arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
    scene.add(arrow);

    [0.3, 0.6].forEach(ct => {
      const cp = curve.getPointAt(ct);
      const cpPrev = curve.getPointAt(ct-0.03);
      const cDir = new THREE.Vector3().subVectors(cp, cpPrev).normalize();
      const chev = new THREE.Mesh(new THREE.ConeGeometry(0.03,0.07,4), new THREE.MeshBasicMaterial({ color:midC, transparent:true, opacity:0.45 }));
      chev.position.copy(cp);
      chev.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), cDir);
      scene.add(chev);
    });

    if (flow.label) {
      const lPos = curve.getPointAt(0.5);
      const lTex = flowLabel3D(flow.label, midC.getStyle());
      const lm = new THREE.Mesh(new THREE.PlaneGeometry(1.3,0.14), new THREE.MeshBasicMaterial({ map:lTex, transparent:true, opacity:0.95, side:THREE.DoubleSide, depthWrite:false }));
      lm.position.copy(lPos);
      lm.position.x += (xOff>=0?0.75:-0.75);
      scene.add(lm);
    }
  });

  // Loops
  (phaseData.loops||[]).forEach(loop => {
    const y0 = -loop.from*SPACING, y1 = -loop.to*SPACING;
    const c = new THREE.Color(loop.color||'#e879f9');
    const xB = 4.8;
    const pts = [];
    for (let j=0; j<=50; j++) {
      const t=j/50;
      const bulge = Math.sin(t*Math.PI);
      pts.push(new THREE.Vector3(xB*bulge, y0+(y1-y0)*t, -0.5*bulge));
    }
    const curve = new THREE.CatmullRomCurve3(pts);

    for (let s=0; s<80; s++) {
      if (s%4===3) continue;
      const t0=s/80, t1=(s+1)/80;
      const p0=curve.getPointAt(t0), p1=curve.getPointAt(t1);
      const mid=p0.clone().lerp(p1,0.5);
      scene.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3([p0,mid,p1]),3,0.02,4,false), new THREE.MeshBasicMaterial({ color:c, transparent:true, opacity:0.55 })));
    }
    scene.add(new THREE.Mesh(new THREE.TubeGeometry(curve,30,0.06,6,false), new THREE.MeshBasicMaterial({ color:c, transparent:true, opacity:0.06, blending:THREE.AdditiveBlending, depthWrite:false })));

    const endPt = curve.getPointAt(0.98), prevPt = curve.getPointAt(0.94);
    const dir = new THREE.Vector3().subVectors(endPt,prevPt).normalize();
    const arr = new THREE.Mesh(new THREE.ConeGeometry(0.07,0.18,5), new THREE.MeshBasicMaterial({ color:c, transparent:true, opacity:0.8 }));
    arr.position.copy(endPt);
    arr.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
    scene.add(arr);

    const apex = curve.getPointAt(0.5);
    const lt = flowLabel3D(loop.label, c.getStyle());
    const lm = new THREE.Mesh(new THREE.PlaneGeometry(2.6,0.16), new THREE.MeshBasicMaterial({ map:lt, transparent:true, opacity:0.95, side:THREE.DoubleSide, depthWrite:false }));
    lm.position.copy(apex); lm.position.x += 0.8;
    scene.add(lm);
  });

  // Particles
  const count = 90;
  const pGeo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  const cols = new Float32Array(count*3);
  const yMin = -(layers.length-1)*SPACING-1, yMax = 1;
  for (let i=0; i<count; i++) {
    pos[i*3]=(Math.random()-0.5)*5;
    pos[i*3+1]=yMin+Math.random()*(yMax-yMin);
    pos[i*3+2]=(Math.random()-0.5)*2.5;
    const cl = new THREE.Color(layers[Math.floor(Math.random()*layers.length)].color);
    cols[i*3]=cl.r; cols[i*3+1]=cl.g; cols[i*3+2]=cl.b;
  }
  pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
  pGeo.setAttribute('color', new THREE.Float32BufferAttribute(cols,3));
  const particles = new THREE.Points(pGeo, new THREE.PointsMaterial({ size:0.04, vertexColors:true, transparent:true, opacity:0.45, blending:THREE.AdditiveBlending, depthWrite:false }));
  particles.userData = { yMin, yMax };
  scene.add(particles);

  camTargetY = -selectedIdx * SPACING;
}

function initThree() {
  const vp = document.getElementById('viewport');
  const w = vp.clientWidth, h = vp.clientHeight;

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x080c14, 0.012);
  scene.add(new THREE.AmbientLight(0x556677, 1.0));
  const dl = new THREE.DirectionalLight(0xffffff, 0.35);
  dl.position.set(4,12,6); scene.add(dl);
  const pl = new THREE.PointLight(0x22d3ee, 0.2, 30);
  pl.position.set(-5,2,5); scene.add(pl);

  camera = new THREE.PerspectiveCamera(38, w/h, 0.1, 100);
  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(w, h);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x080c14, 1);
  vp.insertBefore(renderer.domElement, vp.firstChild);

  clock = new THREE.Clock();

  vp.addEventListener('wheel', e => {
    e.preventDefault();
    camDist = Math.max(5, Math.min(16, camDist + e.deltaY * 0.008));
  }, { passive: false });

  vp.addEventListener('pointerdown', e => { isDrag=true; dragStart={x:e.clientX,y:e.clientY}; });
  vp.addEventListener('pointerup', () => isDrag=false);
  vp.addEventListener('pointermove', e => {
    if (!isDrag) return;
    camAngleTarget.theta += (e.clientX-dragStart.x)*0.004;
    camAngleTarget.phi = Math.max(-0.3, Math.min(1.1, camAngleTarget.phi+(e.clientY-dragStart.y)*0.004));
    dragStart = {x:e.clientX, y:e.clientY};
  });

  window.addEventListener('resize', () => {
    const nw = vp.clientWidth, nh = vp.clientHeight;
    camera.aspect = nw/nh;
    camera.updateProjectionMatrix();
    renderer.setSize(nw, nh);
  });

  animate();
}

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();
  const R = camDist;

  camAngle.theta += (camAngleTarget.theta - camAngle.theta)*0.08;
  camAngle.phi += (camAngleTarget.phi - camAngle.phi)*0.08;
  camera.position.x = R*Math.sin(camAngle.theta)*Math.cos(camAngle.phi);
  camera.position.z = R*Math.cos(camAngle.theta)*Math.cos(camAngle.phi);
  const tgtY = camTargetY + R*Math.sin(camAngle.phi);
  camera.position.y += (tgtY - camera.position.y)*0.10;
  camera.lookAt(0, camTargetY, 0);

  scene.children.forEach(child => {
    if (child instanceof THREE.Points && child.userData.yMin !== undefined) {
      const pos = child.geometry.attributes.position;
      const {yMin, yMax} = child.userData;
      for (let i=0; i<pos.count; i++) {
        let y = pos.getY(i)-0.003;
        if (y < yMin) y = yMax;
        pos.setY(i, y);
        pos.setX(i, pos.getX(i) + Math.sin(t+i)*0.0006);
      }
      pos.needsUpdate = true;
    }
  });

  renderer.render(scene, camera);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  KEYBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.addEventListener('keydown', e => {
  if (e.key==='ArrowDown'||e.key==='j') { e.preventDefault(); setSelected(selectedIdx+1); }
  else if (e.key==='ArrowUp'||e.key==='k') { e.preventDefault(); setSelected(selectedIdx-1); }
  else if (e.key==='1') setPhase('keygen');
  else if (e.key==='2') setPhase('encaps');
  else if (e.key==='3') setPhase('decaps');
  else if (e.key==='p') {
    showPseudo = !showPseudo;
    rebuild();
  }
});

document.getElementById('btn-up').onclick = () => setSelected(selectedIdx-1);
document.getElementById('btn-down').onclick = () => setSelected(selectedIdx+1);
document.getElementById('pc-toggle').onclick = () => { showPseudo = !showPseudo; rebuild(); };

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  REBUILD ALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function rebuild() {
  phaseData = getPhase();
  renderHeader();
  renderFlowchart();
  renderPseudocode();
  renderDetail();
  build3D();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.addEventListener('DOMContentLoaded', () => {
  initThree();
  rebuild();
});
</script>
</body>
</html>
